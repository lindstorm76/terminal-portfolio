import { describe, it, expect, vi, beforeEach } from "vitest";
import { renderHook } from "@testing-library/react";
import { UserInfoProvider, useUserInfo } from "./UserInfoContext";

vi.mock("@scaleway/random-name", () => ({
  default: () => "eps1.0_hellofriend.mov",
}));

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <UserInfoProvider>{children}</UserInfoProvider>
);

describe("useUserInfo", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("throws without provider", () => {
    const spy = vi.spyOn(console, "error").mockImplementation(() => {});

    expect(() => renderHook(() => useUserInfo())).toThrow(
      "useUserInfo must be used within UserInfoProvider",
    );

    spy.mockRestore();
  });

  it("provides a username generated by randomName", () => {
    const { result } = renderHook(() => useUserInfo(), { wrapper });

    expect(result.current.username).toBe("eps1.0_hellofriend.mov");
  });

  it("provides the correct domain", () => {
    const { result } = renderHook(() => useUserInfo(), { wrapper });

    expect(result.current.domain).toBe("terminal.thanapong.dev");
  });

  it("returns the same username across multiple renders", () => {
    const { result, rerender } = renderHook(() => useUserInfo(), { wrapper });

    const first = result.current.username;
    rerender();

    expect(result.current.username).toBe(first);
  });

  it("returns the same instance to all consumers within the same provider", () => {
    const { result: a } = renderHook(() => useUserInfo(), { wrapper });
    const { result: b } = renderHook(() => useUserInfo(), { wrapper });

    expect(a.current.domain).toBe(b.current.domain);
    expect(a.current.username).toBe(b.current.username);
  });
});
